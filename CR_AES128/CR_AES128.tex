\documentclass[french, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\graphicspath{ {./screenshots/} }

\usepackage[explicit]{titlesec}

\titleformat{\section}
{\normalfont\normalsize\bfseries\centering}{}{0em}{\MakeUppercase{#1}}

\newcommand{\subtitle}[1]{%
	\posttitle{%
		\par\end{center}
	\begin{center}\LARGE#1\end{center}
	\vskip0.5em}%
}

\title{UE IN608N (CRYPTO): Attaque intégrale sur une
	version réduite d’un AES-128 }
\subtitle{Rapport IN608}
\author{\hspace{-2cm}Docherty Ronan, Ejjed Zakaria, Gago Jérémy, Guerin Raphaël, Thienard Rodolphe}
\date{10 Mai 2022}


\begin{document}
	\maketitle
	\newpage
	
	\renewcommand{\contentsname}{Sommaire} 
	\tableofcontents
	
	\newpage

	\section{\underline{Introduction}}

	Le but de ce Projet était de d'implémenter une version réduite d'un AES-128 avec un mode de chiffrement OFB et/ou CTR en C.
	Mais aussi et surtout réalisé l'attaque intégrale sur 4 tours de l'AES-128.
	
	\part{\underline{Gestion des commandes et Makefile}}	
	
	Tout d'abord pour lancer le programme il vous suffit de taper \verb|make| dans le terminal. La commande \verb|make| vous affiche les différents arguments a mettre et les modes disponibles. Les arguments disponibles sont les suivant :
	\begin{enumerate}
		\item -a : qui permet de faire l'attaque.
		\item -e : qui permet de faire l'encryptage et le décryptage d'un fichier.
		\item -out : qui permet de nommer le fichier de sortie.
		\item -h : qui permet d'afficher les aides.
		\item -nonce : qui génère un nombre aléatoire pour le CTR.
	\end{enumerate}
	Dans le \verb|Makefile| il existe déjà des commandes types comme \verb|make enc| qui effectue un encryptage sur le fichier \verb|matrices.txt|.
	Nous gérons aussi les erreurs possibles d'arguments, ainsi si les arguments nécessaire ne sont pas présent un message d'erreur apparaîtra.
	 
	\part{\underline{Implémentation de l'AES-128}}
	
	Un tour d'AES-128 est composé de 4 fonctions : 
	
	\begin{enumerate}
		\item SubOctet : Substitue les octets de la matrice d'état.
		\item DecaleLignes : Décale les lignes de la matrice d'état.
		\item MelangeColonnes : Mélanges les colonnes de la matrice d'état.
		\item AjouteCleTour : Ajoute la clé de tour à la matrice d'état.
	\end{enumerate}
  	 
	 Nous commencerons donc par la fonction SubOctet puisque c'est la première fonction du tour.
	
	\section{SubOctet}

	La fonction \verb|suboctet(int **matrix)| nous permet de substituer l'octet contenu dans une case de notre matrice, à l'aide de la table de substitution de l'AES, qui nous donnera un octet différent du précédent.
		
	\section{DecaleLignes}
	
	La fonction \verb|decale_lignes(int **matrix);| permet de décaler les lignes de la matrice d'état en fonction de la ligne. Pour faire cela on créer une matrices (\verb|int **|) temporaire qui stockera le décalage des lignes. Ces modifications serons recopié dans la matrices d'état.
	
	\section{MelangeColonnes}
	
	La fonction \verb|melange_colonnes(int **matrix)| permet, à l'aide de deux matrices( \verb|operation_double| et \verb|operation_triple|), d'effectuer certaines opérations pour donner de nouvelles valeurs aux lignes de chaque colonne de notre matrice. Les opérations sont les suivantes : \\\\
	Avec B{x,y} l'octet contenu dans la ligne x et la colonne y de la matrice entré en argument, B' étant la matrice résultant des opérations,
	\begin{math}
		 2\star B{x,y}  
	\end{math}
	correspondant à l'octet renvoyé par la case de \verb|operation_double|, à la ligne égale à la première partie de l'octet renvoyé par B{x,y} et égale à la colonne de la deuxième partie de cet octet, idem pour 
	\begin{math}
		3\star B_{x,y} 
	\end{math}
	mais cette fois dans la matrice \verb|operation_triple|
	\begin{enumerate}
		\vspace{0.5cm}
		\item \hspace{2cm}
		\begin{math}
			B'_{0,1} = (2 \star B_{0,1}) \oplus (3 \star B_{1,1}) \oplus B_{2,1} \oplus B_{3,1}
		\end{math} \\
		La première ligne prendra la valeur de: l'octet renvoyé par la case correspondant à l'octet de la ligne 0 de cette colonne dans \verb|operation_double| XOR l'octet renvoyé par la case correspondant à l'octet de la ligne 1 dans \verb|operation_triple| XOR l'octet de la ligne 2 XOR l'octet de la ligne 3.
		\vspace{0.5cm}
		\item \hspace{2cm}
		\begin{math}
			B'_{1,1} = B_{0,1} \oplus (2 \star B_{1,1}) \oplus (3 \star B_{2,1}) \oplus B_{3,1}
		\end{math} \\
		La seconde prendra la valeur de: l'octet de la ligne 0 XOR  l'octet renvoyé par la case correspondant à l'octet de la ligne 1 dans \verb|operation_double| XOR l'octet renvoyé par la case correspondant à l'octet de la ligne 2 dans \verb|operation_triple| XOR l'octet de la ligne 3
		\vspace{0.5cm}
		\item \hspace{2cm}
		\begin{math}
			B'_{2,1} = B_{0,1} \oplus B_{1,1} (2 \star B_{2,1}) \oplus (3 \star B_{3,1})
		\end{math} \\
		La troisième prendra la valeur de: l'octet de la ligne 0 XOR l'octet de la ligne 1 XOR  l'octet renvoyé par la case correspondant à l'octet de la ligne 2 dans \verb|operation_double| XOR l'octet renvoyé par la case correspondant à l'octet de la ligne 3 dans \verb|operation_triple| 
		\vspace{0.5cm}
		\item \hspace{2cm}
		\begin{math}
			B'_{3,1} = (3 \star B_{0,1}) \oplus B_{1,1} \oplus B_{2,1} (2 \star B_{3,1})
		\end{math} \\
		La dernière prendra la valeur de: l'octet renvoyé par la case correspondant à l'octet de la ligne 0 dans \verb|operation_triple| XOR l'octet de la ligne 1 XOR l'octet de la ligne 2 XOR  l'octet renvoyé par la case correspondant à l'octet de la ligne 3 dans \verb|operation_double|
	\end{enumerate}

	\section{AjouteCleTour}
	
	La fonction \verb|addroundkey(int **matrix, int **key);| fait un XOR entre la matrice d'état courante et la matrice de la clé de tour.
	
	\section{Les Tours}
	
	Pour les tours d'AES nous avons une fonction \verb|turn(int matrix, int key)|, qui effectue les fonctions précédemment cité (dans le même ordre), nous avons ensuite une fonction  \verb|last_turn(int matrix, int key)| qui effectue les même fonctions que \verb|turn| à part la fonction \verb|melange_colonne| et enfin \\ \verb|aes(int matrix, int extended_key, int turns)| qui effectue un nombre définit de fois la fonction \verb|turn| et qui termine par une itération de \verb|last_turn|, dans notre cas 10 tour.
	
	\section{Gestion des clé}
	
	L'AES-128 utilise 2 clés différentes : 
	\begin{enumerate}
		\item - \textbf{La clé Maitre}
		\item - \textbf{La clé de Tour}
	\end{enumerate}
	La clé Maitre est donnée par l'utilisateur en entrée et doit faire 128 bits. La clé de tour quand a elle n'est pas donné en entrée mais utilise la clé maitre pour être créer et change à chaque tour qu'effectue l'AES.
	
	\subsection{Clé Maitre}
	Comme dit précédemment la clé maitre est la clé principale de l'AES-128. Cette clé est donnée par l'utilisateur et doit obligatoirement faire 128 bits. Cette clé est utilisé pour la création des clé de Tour. La clé Maitre étant donné en argument elle est de type \verb|char*|, nous avons donc créé une fonction qui convertit les \verb|char*| en matrices (en \verb|int **|) \verb|str_to_matrix(char *key)|. 
	
	\subsection{Clé de Tour}
	Pour générer la clé de Tour nous avons besoin d'étendre la clé de maitre de 128 bits à 1408 bits. Puis chaque portion de 128 bits de la clé maitre étendue deviens une clé de tour. Comme il y a dix tours il y a 10 clé de tour, plus une pour le dernier tour. La clé de tour est donc généré chaque tour par la fonction \verb|key_extension(int **master_key, int **extended_key)| qui à partir de la clé maitre effectue un SubOctet sur la RotationOctet d'une clé tampon puis un XOR avec les constantes Rcon. L'action RotationOctet est effectué dans \verb|rotation_left(int *tampon)| et les constantes Rcon dans un variable du même nom.
	
	\section{Chiffrement CTR}
	
	Pour faire le chiffrement CTR nous utilisons une fonction\\ \verb|counter_mode(int matrix, int extended_key, int **plaintext, int turns)| qui après avoir fait des tours d'AES sur une matrice, XOR cette matrice avec une matrice contenant 16 bits de texte clair, nous utilisons aussi une fonction \verb| loop_ctr(struct chained_matrixchained, int matrix, int extended_key,| \verb|int turns)| qui quant à elle nous place à la fin du message clair et qui effectue la fonction \verb|counter_mode| avec les bouts de texte clair autant de fois qu'il y'a de bouts.

\end{document}
